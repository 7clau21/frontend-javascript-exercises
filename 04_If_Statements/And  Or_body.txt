Simple `if` statements are often sufficient for basic branches, but sometimes you'll need to create complex branch scenarios. Ruby provides operators that add conditional logic to `if` statements. Specifically, `&&` and `||` are logical operators that represent "and" and "or", respectively. Consider the following example:

> You can read this as "if I have more than 5 dollars _and_ I'm hungry, then give me an apple."

```ruby
if money > 5 && hungry == true
  "give me an apple"
end
```

> Pro tip: Common Ruby conventions discourage the use of `== true` because it is redundant. The `&&` operator is already looking for a `true` or `false` value on either side of it. Therefore, the only way that hungry would be "equal to true", is if it is `true`. You could refactor the `if` statement as:

```ruby
if money > 5 && hungry
  "give me an apple"
end
```

This statement will return `"give me an apple"` only if the conditions on both sides of the `&&` operator are `true`. Alternatively, if you wanted to return `"give me an apple"` if either `money > 5` _or_ `hungry` is `true`, then you could write:

```ruby
if money > 5 || hungry
  "give me an apple"
end
```

If you are writing a complex conditional statement, it may be helpful to frame your logical statements with parenthesis. For example, you could refactor the statement above as:

```ruby
if (money > 5) || (hungry)
  "give me an apple"
end
```

`if` statements simply look for a `true` or `false` value. To be clear, `true` and `false` values do not have to be boolean values. In Ruby, `nil` and `false` are all considered to be "false-y" values. Everything else in Ruby is naturally true. Consider the following example:

```ruby
def is_true(a)
  if a
    "true"
  else
    "false"
  end
end

is_true("hello") #=> will return "true"
is_true(4)       #=> will return "true"
is_true(true)    #=> will return "true"
is_true(nil)     #=> will return "false"
is_true(false)   #=> will return "false"
```

To complete this exercise, create two methods:

The `lock` method should take four arguments:

```ruby
def lock(a,b,c,d)
end
```

Each argument represents a number on a combination lock. The method will return "unlocked" or "locked" based on if the combination is correct. There are several combinations that are "correct".

* The first number has to be a 3, 5, or 7
* The second number has to be a 2
* The third number has to be a 5 or a 6
* The fourth number has to be 8, 9 or 0

An example of satisfying the first number condition could be:

```ruby
if (a == 3 || a == 5 || a == 7)
```

The `can_i_get?` method should take two arguments:

```ruby
def can_i_get?(item,money)
end
```

The first argument represents what the user wants to buy. 

> According to the specs below, the user can buy a computer or iPad.

The second argument represents how much money they have. The method should evaluate if they have enough money to buy a computer or iPad. If they do have enough money for a computer or iPad, the method should return `true`, otherwise it should return `false`. An example for the first condition could be:

```ruby
if item == "computer" && money >= 1000
```

Try to use `elsif` rather than separate `if` statements.

***